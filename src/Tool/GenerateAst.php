<?php

namespace Tool;

/**
 * Generate the type classes used in the AST
 */
class GenerateAst
{
    public static function main()
    {
        $outputDir = realpath(__DIR__ . "/../App/Ast");

        self::defineAst(
            $outputDir."/Expr",
            "Expr",
            [
                "Assign   : \\App\\Token \$name, Expr \$value",
                "Binary   : Expr \$left, \\App\\Token \$operator, Expr \$right",
                "Call     : Expr \$callee, \\App\\Token \$paren, array \$arguments",
                "Get      : Expr \$object, \\App\\Token \$name",
                "Set      : Expr \$object, \\App\\Token \$name, Expr \$value",
                "Super    : \\App\\Token \$keyword, \\App\\Token \$method",
                "ThisExpr : \\App\\Token \$keyword",
                "Grouping : Expr \$expression",
                "Literal  : \$value",
                "Logical  : Expr \$left, \\App\\Token \$operator, Expr \$right",
                "Unary    : \\App\\Token \$operator, Expr \$right",
                "Variable : \\App\\Token \$name",
            ]
        );
        self::defineAst(
            $outputDir."/Stmt",
            "Stmt",
            [
                "Block      : array \$statements",
                "Expression : \\App\\Ast\\Expr\\Expr \$expression",
                "ClassDecl  : \\App\\Token \$name, ?\\App\\Ast\\Expr\\Expr \$superclass, array \$methods",
                "FunctionDecl: \\App\\Token \$name, array \$parameters, array \$body",
                "Conditional: \\App\\Ast\\Expr\\Expr \$condition, Stmt \$thenBranch, ?Stmt \$elseBranch",
                "Prnt       : \\App\\Ast\\Expr\\Expr \$expression",
                "FnReturn   : \\App\\Token \$keyword, ?\\App\\Ast\\Expr\\Expr \$value",
                "Variable   : \\App\\Token \$name, ?\\App\\Ast\\Expr\\Expr \$initializer",
                "WhileLoop  : \\App\\Ast\\Expr\\Expr \$condition, Stmt \$body",
                "BreakStmt  : \\App\\Token \$token",
            ]
        );

        return 1;
    }

    private static function cleanTargetDir($outputDir)
    {
        $dirIter = new \DirectoryIterator($outputDir);

        foreach ($dirIter as $file) {
            if ($file->getExtension() === "php") {
                unlink($file->getPathname());
            }
        }
    }

    private static function writeAutogeneratedWarning(\SplFileObject $outputFile)
    {
        $outputFile->fwrite("/**\n");
        $outputFile->fwrite(" * THIS FILE IS AUTO-GENERATED, DO NOT CHANGE IT MANUALLY\n");
        $outputFile->fwrite(" */\n");
    }

    private static function defineAst(string $outputDir, string $baseName, array $types)
    {
        $outputFile = new \SplFileObject($outputDir . "/" . $baseName . ".php", "w");
        $outputFile->fwrite("<?php\n\n");
        self::writeAutogeneratedWarning($outputFile);
        $outputFile->fwrite("namespace App\\Ast\\$baseName;\n");
        $outputFile->fwrite("\n");
        $outputFile->fwrite("abstract class $baseName \n{\n");
        $outputFile->fwrite("       abstract public function accept({$baseName}Visitor \$visitor);\n");
        $outputFile->fwrite("}\n");
        unset($outputFile);

        self::defineSubclasses($outputDir, $baseName, $types);
        self::defineVisitorInterface($outputDir, $baseName, $types);
    }

    private static function defineVisitorInterface(string $outputDir, string $baseName, array $types)
    {
        $outFile = new \SplFileObject($outputDir . "/{$baseName}Visitor.php", "w");
        $outFile->fwrite("<?php\n\n");
        self::writeAutogeneratedWarning($outFile);
        $outFile->fwrite("namespace App\\Ast\\$baseName;\n");
        $outFile->fwrite("\n");
        $outFile->fwrite("interface {$baseName}Visitor {\n");

        foreach ($types as $type) {
            $typeName = trim(explode(":", $type)[0]);
            $outFile->fwrite("      public function visit$typeName$baseName($typeName \$".strtolower($baseName).");\n");
        }

        $outFile->fwrite("}\n");
        unset($outFile);
    }

    private static function normalizeTypeNameForReturn(string $typeName)
    {
        if ($typeName[0] === "?") {
            return substr($typeName, 1);
        }

        return $typeName;
    }

    private static function defineSubclasses(string $outputDir, string $baseName, array $types)
    {
        foreach ($types as $type) {
            $className = trim(explode(":", $type)[0]);
            $fields = trim(explode(":", $type)[1]);
            self::defineSubclass($outputDir, $baseName, $className, $fields);
        }
    }

    private static function defineSubclass(string $outputDir, string $baseName, string $className, string $fields)
    {
        //Expr left, Token operator, Expr right
        $outputFile = new \SplFileObject($outputDir . "/" . $className . ".php", "w");
        $outputFile->fwrite("<?php\n\n");
        self::writeAutogeneratedWarning($outputFile);
        $outputFile->fwrite("namespace App\\Ast\\$baseName;\n");
        $outputFile->fwrite("\n");
        $outputFile->fwrite("class $className extends $baseName \n{\n");
        $outputFile->fwrite("\n");

        // constructor and arguments
        $outputFile->fwrite("    public function __construct($fields)\n    {\n");

        foreach (explode(",", $fields) as $field) {
            $name = explode(" ", trim($field));
            if (isset($name[1])) {
                $strName = $name[1];
            } else {
                $strName = $name[0];
            }

            $nameInstance = str_replace("\$", "\$this->", $strName);

            $outputFile->fwrite("        $nameInstance = $strName;\n");
        }

        $outputFile->fwrite("    }\n\n");

        // define visitor accept method
        $outputFile->fwrite("   public function accept({$baseName}Visitor \$visitor)\n");
        $outputFile->fwrite("   {\n");
        $outputFile->fwrite("       return \$visitor->visit$className$baseName(\$this);\n");
        $outputFile->fwrite("   }\n\n");

        // define properties and getters
        foreach (explode(",", $fields) as $field) {
            $name = explode(" ", trim($field));
            if (isset($name[1])) {
                $strName = $name[1];
            } else {
                $strName = $name[0];
            }

            // property declaration and type hint
            if (isset($name[1])) {
                $outputFile->fwrite("    /**\n");
                $outputFile->fwrite("     * @var ".self::normalizeTypeNameForReturn($name[0])."\n");
                $outputFile->fwrite("     */\n");
            }
            $outputFile->fwrite("    private $strName;\n");
            $outputFile->fwrite("\n");

            // getter and type hint
            if (isset($name[1])) {
                $outputFile->fwrite("    /**\n");
                $outputFile->fwrite("     * @return ".self::normalizeTypeNameForReturn($name[0])."\n");
                $outputFile->fwrite("     */\n");
            }
            $outputFile->fwrite(sprintf("    public function get%s()\n", ucfirst(str_replace("\$", "", $strName))));
            $outputFile->fwrite("    {\n");
            $outputFile->fwrite(sprintf("        return \$this->%s;\n", str_replace("\$", "", $strName)));
            $outputFile->fwrite("    }\n\n");
        }


        $outputFile->fwrite("}\n");
        unset($outputFile);
    }
}
